<template>
  <q-page
    :key="activeAsset.id"
    class="stl-footer--bottom"
  >
    <div class="row justify-center">
      <div class="gt-md">
        <QPageSticky position="top-right" :offset="[50, 20]">
          <TransactionCard />
        </QPageSticky>
      </div>
      <div class="full-width stl-content-container q-pb-xl">
        <div class="q-px-lg q-pt-lg">
          <AppSwitchableEditor
            tag="h1"
            class="text-h4 text-weight-bold q-my-xs"
            :value="activeAsset.name"
            :active="isCurrentUserTheOwner"
            :custom-save="updateAssetFn('name')"
            :input-label="$t({ id: 'asset.name_label' })"
          />
          <AppContent
            v-if="activeAsset.id && (!isAvailable || !activeAsset.active)"
            class="text-uppercase non-selectable"
            tag="QChip"
            entry="asset"
            field="unavailable"
            square
            color="warning"
            text-color="white"
          />

          <AppContent
            v-if="activeAsset.startDate"
            tag="div"
            class="text-body1 text-weight-medium"
            entry="time"
            field="from_start_date_to_end_date"
            :options="{ startDate: activeAsset.startDate, endDate: activeAsset.endDate }"
          />
        </div>

        <div class="row justify-between q-px-lg q-my-md">
          <AppSwitchableEditor
            v-if="isPlaceSearchEnabled"
            tag="div"
            class="col-6 text-body1"
            :value="activeAsset.locationName"
            :active="isCurrentUserTheOwner"
            :custom-save="updateAssetFn('locations')"
          >
            <template>
              <!-- v-slot:default="{ content }" -->
              <div class="text-h6 ellipsis">
                {{ activeAsset.locationName }}
              </div>
            </template>
            <template v-slot:placeholder>
              <AppContent
                entry="places"
                field="address_placeholder"
              />
            </template>
            <template v-slot:edition="{ content, saveDraft }">
              <PlacesAutocomplete
                :initial-query="activeAsset.locationName"
                :label="$t({ id: 'places.address_placeholder' })"
                @selectPlace="loc => prepareUpdatedLocations(loc, saveDraft)"
              />
            </template>
          </AppSwitchableEditor>

          <AppSwitchableEditor
            tag="div"
            class="flex-item--auto text-h5 text-weight-medium"
            :value="activeAsset.price"
            :active="isCurrentUserTheOwner"
            :custom-save="updateAssetFn('price')"
            :input-label="$t({ id: 'pricing.price_label' })"
            input-type="number"
          >
            <AppContent
              v-if="activeAsset.assetType && activeAsset.assetType.timeBased"
              entry="pricing"
              field="price_per_time_unit_label"
              :options="{
                price: $fx(activeAsset.price),
                timeUnit: activeAsset.timeUnit
              }"
            />
            <AppContent
              v-else
              entry="pricing"
              field="price_with_currency"
              :options="{ price: $fx(activeAsset.price) }"
            />
          </AppSwitchableEditor>
        </div>

        <div class="text-center q-mb-md">
          <div v-if="!isEditingImages">
            <VuePhotoSwipe
              v-if="galleryItems.length"
              :options="getResourceGalleryOptions(activeAsset)"
              :items="galleryItems"
            />
            <AppContent
              v-if="isCurrentUserTheOwner"
              class="q-ma-lg"
              tag="QBtn"
              color="primary"
              entry="prompt"
              :field="galleryItems.length ? 'edit_pictures' : 'add_pictures'"
              :rounded="style.roundedTheme"
              @click="toggleImageEdition"
            />
          </div>
          <div v-else-if="isCurrentUserTheOwner">
            <AppGalleryUploader
              :reused-images="activeAsset.images"
              @upload-completed="uploadCompleted"
              @reorder="files => uploadCompleted({ uploadedOrReused: files })"
              @remove="removeImage"
            />
            <AppContent
              class="q-ma-md"
              tag="QBtn"
              color="positive"
              entry="navigation"
              field="close"
              :rounded="style.roundedTheme"
              @click="toggleImageEdition(false)"
            />
          </div>
        </div>

        <div class="q-pa-sm text-body1">
          <AppContent
            tag="h3"
            class="text-h4 text-weight-medium"
            entry="asset"
            field="description_label"
          />

          <AppSwitchableEditor
            tag="p"
            class="q-my-lg q-mx-sm text-justify"
            :value="activeAsset.description"
            :active="isCurrentUserTheOwner"
            :custom-save="updateAssetFn('description')"
            :input-label="$t({ id: 'asset.description_label' })"
            allow-falsy-save
            input-type="textarea"
          />
          <div class="row text-left">
            <div class="col-12 col-md-5">
              <label v-if="isCurrentUserTheOwner" class="customck">
                Pickup
                <input
                  id="pickup"
                  type="checkbox"
                  :value="activeAsset.metadata.pickup"
                  :checked="activeAsset.metadata.pickup"
                  @change="changepickupdelivery"
                >
                <span class="checkmark"></span>
              </label>
              <label v-else class="">
                <svg
                  aria-hidden="true"
                  role="presentation"
                  focusable="false"
                  viewBox="0 0 24 24"
                  class="q-mr-sm q-icon notranslate text-secondary"
                  style="font-size: 1.5rem;"
                >
                  <path d="M14.12,10H19V8.2H15.38L13.38,4.87C13.08,4.37 12.54,4.03 11.92,4.03C11.74,4.03 11.58,4.06 11.42,4.11L6,5.8V11H7.8V7.33L9.91,6.67L6,22H7.8L10.67,13.89L13,17V22H14.8V15.59L12.31,11.05L13.04,8.18M14,3.8C15,3.8 15.8,3 15.8,2C15.8,1 15,0.2 14,0.2C13,0.2 12.2,1 12.2,2C12.2,3 13,3.8 14,3.8Z"></path>
                </svg>
                Pickup
              </label>
              <div v-if="isCurrentUserTheOwner">
                <label class="customck">
                  Local delivery
                  <input
                    id="local"
                    type="checkbox"
                    value="local"
                    :checked="(activeAsset.metadata.deliverytype.indexOf('local') !== -1) ? true:false"
                    @change="changedeliveryoptions"
                  >
                  <span class="checkmark"></span>
                </label>
                <label class="customck">
                  Long distance delivery
                  <input
                    id="distance"
                    type="checkbox"
                    value="distance"
                    :checked="(activeAsset.metadata.deliverytype.indexOf('distance') !== -1) ? true:false"
                    @change="changedeliveryoptions"
                  >
                  <span class="checkmark"></span>
                </label>
              </div>
              <div v-else>
                <label class="">
                  <svg
                    v-if="activeAsset.metadata.deliverytype.indexOf('local') !== -1 || activeAsset.metadata.deliverytype.indexOf('distance') !== -1"
                    aria-hidden="true"
                    role="presentation"
                    focusable="false"
                    viewBox="0 0 24 24"
                    class="q-mr-sm q-icon notranslate text-secondary"
                    style="font-size: 1.5rem;"
                  >
                    <path d="M19 15C19.55 15 20 15.45 20 16C20 16.55 19.55 17 19 17S18 16.55 18 16C18 15.45 18.45 15 19 15M19 13C17.34 13 16 14.34 16 16S17.34 19 19 19 22 17.66 22 16 20.66 13 19 13M10 6H5V8H10V6M17 5H14V7H17V9.65L13.5 14H10V9H6C3.79 9 2 10.79 2 13V16H4C4 17.66 5.34 19 7 19S10 17.66 10 16H14.5L19 10.35V7C19 5.9 18.11 5 17 5M7 17C6.45 17 6 16.55 6 16H8C8 16.55 7.55 17 7 17Z"></path>
                  </svg>
                  Delivery
                </label>
              </div>
            </div>
          </div>
          <div
            v-if="assetCustomAttributes.length"
            class="row text-weight-medium q-py-sm"
          >
            <div v-if="isCurrentUserTheOwner">
              <CustomAttributesEditor
                :definitions="customAttributesOfTypes(['boolean'])"
                :values="activeAsset.customAttributes"
                @change="changeCustomAttributes"
              />
            </div>
            <div v-else>
              <!-- We only keep truthy customAttributes values but depending on UI we could need falsy ones as well -->
              <!-- For instance: `smoking: false` -->
              <div
                v-for="attribute in assetCustomAttributes.filter(ca => !!ca.value && ca.type === 'boolean')"
                :key="attribute.name"
                class="non-selectable col-12 col-sm-4 q-mb-sm"
              >
                <QIcon
                  class="q-mr-sm"
                  :name="attribute.icon"
                  color="secondary"
                  size="1.5rem"
                />
                <AppContent
                  :entry="attribute.label.entry"
                  :field="attribute.label.field"
                  :default-message="attribute.label.default"
                />
              </div>
            </div>
          </div>

          <div v-if="assetCustomAttributes.length" class="q-py-sm">
            <div
              v-for="attribute in assetCustomAttributes.filter(
                ca => ca.type === 'text' && !isShortTextValue(ca.value)
              )"
              :key="attribute.name"
            >
              <div
                v-if="isCurrentUserTheOwner || (!isCurrentUserTheOwner && !!attribute.value)"
                class="q-mb-lg"
              >
                <AppContent
                  tag="h3"
                  class="text-h4 q-mt-sm text-weight-medium"
                  :entry="attribute.label.entry"
                  :field="attribute.label.field"
                  :default-message="attribute.label.default"
                />
                <div>
                  <AppSwitchableEditor
                    :value="attribute.value"
                    :active="isCurrentUserTheOwner"
                    :custom-save="updateAssetFn(attribute.name, true)"
                    allow-falsy-save
                  />
                </div>
              </div>
            </div>

            <div
              v-for="attribute in assetCustomAttributes.filter(
                ca => ca.type === 'text' && isShortTextValue(ca.value)
              )"
              :key="attribute.name"
            >
              <div
                v-if="isCurrentUserTheOwner || (!isCurrentUserTheOwner && !!attribute.value)"
                class="row"
              >
                <AppContent
                  class="text-weight-medium col-12 col-sm-4 q-mb-sm"
                  :entry="attribute.label.entry"
                  :field="attribute.label.field"
                  :default-message="attribute.label.default"
                />
                <div class="col-12 col-sm-4 q-mb-md">
                  <AppSwitchableEditor
                    :value="attribute.value"
                    :active="isCurrentUserTheOwner"
                    :custom-save="updateAssetFn(attribute.name, true)"
                    allow-falsy-save
                  />
                </div>
              </div>
            </div>
          </div>
        </div>

        <section
          v-show="assetRatingsLoaded && ratingsActive"
          class="q-mt-md"
        >
          <QSeparator class="q-mt-xl" />

          <TransactionRatingsList
            :ratings="assetRatingsByTransaction"
            :target="activeAsset.owner"
            :show-asset-name="false"
            filter-on-asset
          />
        </section>

        <section
          v-if="similarAssets.length"
          class="q-px-sm"
        >
          <q-separator class="q-mt-lg" />

          <AppContent
            tag="h3"
            class="text-h4 text-weight-medium"
            entry="asset"
            field="similar_assets"
          />
          <div class="row q-col-gutter-md justify-assets">
            <AssetCard
              v-for="asset of similarAssets"
              :key="asset.id"
              class="col-10 col-sm-6"
              :asset="asset"
            />
          </div>
        </section>

        <div class="q-mt-xl">
          <ProfileCard />
        </div>

        <section
          v-if="ownerAssets.length"
          class="q-px-sm"
        >
          <QSeparator class="q-mt-xl" />

          <AppContent
            tag="h3"
            class="text-h4 text-weight-medium"
            entry="user"
            field="assets_title"
            :options="{ user: (isCurrentUserTheOwner ? '_SELF_' : ownerDisplayName) || undefined }"
          />
          <div class="row q-col-gutter-md justify-assets">
            <component
              :is="isCurrentUserTheOwner ? 'OwnerAssetCard' : 'AssetCard'"
              v-for="asset of ownerAssets"
              :key="asset.id"
              class="col-10 col-sm-6"
              :asset="asset"
              @remove="removeAsset"
            />
          </div>
        </section>
      </div>
    </div>
    <AppFooter />
  </q-page>
</template>

<script>
import { mapState, mapGetters } from 'vuex'
import { get, map, sortBy, values, compact, flatten, groupBy, isUndefined } from 'lodash'
// WARNING: icons referenced in customAttributes should be included below
import { mdiWhiteBalanceSunny, mdiImage, mdiSprout, mdiBarleyOff, mdiMoped, mdiWalk } from '@quasar/extras/mdi-v4'

import { extractLocationDataFromPlace, isPlaceSearchEnabled } from 'src/utils/places'
import { populateAsset } from 'src/utils/asset'

import * as mutationTypes from 'src/store/mutation-types'
import CustomAttributesEditor from 'src/components/CustomAttributesEditor'
import OwnerAssetCard from 'src/components/OwnerAssetCard'
import PlacesAutocomplete from 'src/components/PlacesAutocomplete'
import TransactionCard from 'src/components/TransactionCard'
import ProfileCard from 'src/components/ProfileCard'
import TransactionRatingsList from 'src/components/TransactionRatingsList'

import PageComponentMixin from 'src/mixins/pageComponent'
import PaymentMixin from 'src/mixins/payment'

export default {
  components: {
    CustomAttributesEditor,
    OwnerAssetCard,
    PlacesAutocomplete,
    TransactionCard,
    TransactionRatingsList,
    ProfileCard,
    VuePhotoSwipe: () => import(/* webpackChunkName: 'photoswipe' */ 'src/components/VuePhotoSwipe'),
  },
  mixins: [
    PageComponentMixin,
    PaymentMixin,
  ],
  data () {
    return {
      ownerSimilarAssets: [],
      similarAssets: [],
      shortTextMaxLength: 128,
      checkoutDialogOpened: false,
      assetRatingsByTransaction: [],
      assetRatingsLoaded: false,
      isEditingImages: false,
      isPlaceSearchEnabled,
      selectedcountry: '',
    }
  },
  metaInfo () { // SEO, overriding any hard-coded content in translations
    return {
      title: this.activeAsset.name,
      meta: [{
        name: 'description',
        vmid: 'description',
        content: this.activeAsset.description
      }]
    }
  },
  computed: {
    assetCustomAttributes () {
      const attrs = Object.assign({}, this.activeAsset.customAttributes)
      const definitions = this.common.customAttributesById

      const assetTypeId = this.activeAsset.assetTypeId
      const config = this.common.config
      const editableCustomAttributeNames = get(config, `stelace.instant.assetTypes.${assetTypeId}.customAttributes`) || []

      // set to `null` undefined editable asset custom attributes
      // so they can appear in the UI for the owner
      editableCustomAttributeNames.forEach(name => {
        if (isUndefined(attrs[name])) attrs[name] = null
      })

      const populatedAssetAttrs = map(attrs, (v, k) => {
        const def = values(definitions).find(d => d.name === k)
        // FIXME: create a map of stings to 'mdiIcon' name
        // custom attribute icon
        if (def.materialIcon === 'insert_photo') def.icon = this.icons.mdiImage
        if (def.materialIcon === 'wb_sunny') def.icon = this.icons.mdiWhiteBalanceSunny
        if (def.materialIcon === 'grass') def.icon = this.icons.mdiSprout
        if (def.materialIcon === 'no_food') def.icon = this.icons.mdiBarleyOff
        if (def.materialIcon === 'directions_walk') def.icon = this.icons.mdiWalk
        if (def.materialIcon === 'delivery_dining') def.icon = this.icons.mdiMoped
        return Object.assign({ value: v }, def)
      })

      return sortBy(populatedAssetAttrs, ca => -ca.priority)
    },
    customAttributes () {
      return values(this.common.customAttributesById)
    },
    customAttributesByType () {
      const customAttributes = this.customAttributes // ensure Vue reactivity
      return groupBy(customAttributes, ca => ca.type)
    },
    galleryItems () {
      return this.getResourceGalleryItems(this.activeAsset)
    },
    isCurrentUserTheOwner () {
      return this.currentUser.id === this.activeAsset.ownerId
    },
    ownerDisplayName () {
      return get(this.activeAsset, 'owner.displayName')
    },
    ownAssets () {
      if (!this.isCurrentUserTheOwner) return []
      return this.usersAssets[this.currentUser.id] || []
    },
    ownerAssets () {
      return this.isCurrentUserTheOwner ? this.ownAssets : this.ownerSimilarAssets
    },
    isAvailable () {
      return this.isActiveAssetAvailable
    },
    ispickup () {
      // this.pickup = this.activeAsset.metadata.pickup
      return this.activeAsset.metadata.pickup
    },
    ...mapState([
      'asset',
      'common',
      'layout',
      'route',
      'transaction',
      'rating',
      'style',
    ]),
    ...mapGetters([
      'activeAsset',
      'usersAssets',
      'getResourceGalleryItems',
      'getResourceGalleryOptions',
      'currentUser',
      'searchOptions',
      'isActiveAssetAvailable',
      'ratingsOptions',
      'ratingsActive',
      'paymentActive',
      'conversations',
    ]),
  },
  watch: {
    currentUser (current, previous) {
      if (current.id === previous.id) return
      this.afterAuth()
      this.selectedcountry = this.activeAsset.metadata.country
      if (this.paymentActive && current.id) this.viewConversationAfterSuccessfulPayment()
    },
    $route () {
      this.fetchRelatedAssets()
      this.resetTransactionParameters()
      this.$store.dispatch('resetTransactionPreview')
      this.fetchAssetRatingsByTransaction()
    },
    maxAvailableQuantity () {
      if (this.maxAvailableQuantity < this.quantity) {
        this.selectQuantity(this.maxAvailableQuantity)
      }
    }
  },
  async preFetch ({ store, currentRoute, redirect }) {
    const { id: assetId } = currentRoute.params

    try {
      await store.dispatch('fetchActiveAsset', { assetId })
    } catch (err) {
      const code = err.statusCode
      if (code >= 400 && code < 500) redirect(`/${code}`) // needs a string for SSR
      else throw err
    }
  },
  created () {
    this.icons = {
      mdiImage,
      mdiWhiteBalanceSunny,
      mdiSprout,
      mdiBarleyOff,
      mdiMoped,
      mdiWalk
    }
  },
  methods: {
    afterAuth () {
      // Not blocking. Move to (blocking) preFetch and remove $route watcher if optimizing for SEO
      // with server-side rendering (SSR)
      this.fetchRelatedAssets()
      this.fetchAssetRatingsByTransaction()
    },
    toggleImageEdition (editing) {
      this.isEditingImages = typeof editing === 'boolean'
        ? editing : !this.isEditingImages
    },
    uploadCompleted ({ uploadedOrReused }) {
      return this.updateAssetFn('images')(uploadedOrReused)
    },
    removeImage (removed) { // one single image
      const newImages = this.activeAsset.images.filter(img => img.name !== removed.name)
      return this.updateAssetFn('images')(newImages)
    },
    updateAssetFn (fieldName, isCustomAttribute) {
      return async (value) => {
        const attrs = {}
        if (fieldName === 'images') {
          attrs.metadata = {
            images: value
          }
        } else if (fieldName === 'pickup') {
          attrs.metadata = {
            pickup: value
          }
        } else if (fieldName === 'delivery') {
          attrs.metadata = {
            delivery: value
          }
        } else if (fieldName === 'local') {
          attrs.metadata = {
            deliverytype: value
          }
        } else if (fieldName === 'distance') {
          attrs.metadata = {
            deliverytype: value
          }
        } else if (fieldName === 'country') {
          attrs.metadata = {
            country: this.selectedcountry
          }
        } else if (fieldName === 'customAttributes') {
          attrs.customAttributes = value
        } else if (isCustomAttribute) {
          attrs.customAttributes = {
            [fieldName]: value
          }
        } else {
          attrs[fieldName] = value
        }

        await this.$store.dispatch('updateActiveAsset', {
          assetId: this.activeAsset.id,
          attrs
        })
        this.notifySuccess('notification.saved')
      }
    },
    isShortTextValue (value) {
      return typeof value !== 'string' || value.length <= this.shortTextMaxLength
    },
    changeCustomAttributes (customAttributes) {
      return this.updateAssetFn('customAttributes')(customAttributes)
    },
    changecountryoption (val) {
      return this.updateAssetFn('country')(val.target.value)
    },
    changepickupdelivery (val) {
      return this.updateAssetFn(val.target.id)(val.target.checked)
    },
    changedeliveryoptions (val) {
      var index = this.activeAsset.metadata.deliverytype.indexOf(val.target.id)
      if (index !== -1) this.activeAsset.metadata.deliverytype.splice(index, 1)
      else this.activeAsset.metadata.deliverytype.push(val.target.id)
      return this.updateAssetFn(val.target.id)(this.activeAsset.metadata.deliverytype)
    },
    customAttributesOfTypes (types) {
      if (!Array.isArray(types)) return []
      return compact(flatten(types.map(t => this.customAttributesByType[t])))
    },
    prepareUpdatedLocations (place, handlerFn) {
      extractLocationDataFromPlace(place, loc => { handlerFn(loc ? [loc] : null) })
      // Note: array of locations expected, app handles only one for now.
    },
    async fetchAssetRatingsByTransaction () {
      if (!this.ratingsActive) return

      this.assetRatingsByTransaction = await this.$store.dispatch('fetchRatingsByTransaction', { assetId: this.activeAsset.id })
      this.assetRatingsLoaded = true
    },
    async fetchRelatedAssets () {
      await this.$store.dispatch('fetchAssetTypes')

      const assetTypeId = get(this.searchOptions, 'modes.default.assetTypesIds', [])

      const ownerId = get(this.activeAsset, 'ownerId')
      if (!ownerId) return {}

      if (this.isCurrentUserTheOwner) {
        await this.$store.dispatch('fetchUserAssets')
      } else {
        this.ownerSimilarAssets = await this.$store.dispatch('fetchAssets', {
          filters: {
            quantity: 1,
            assetTypeId,
            similarTo: this.activeAsset.id,
            filter: `_ownerId == ${ownerId}`
          },
          nbResults: 4
        })

        if (this.ratingActive) {
          const ownerSimilarAssetIds = this.ownerSimilarAssets.map(asset => asset.id)
          await this.$dispatch('fetchRatingsStats', { assetId: ownerSimilarAssetIds, groupBy: 'assetId' })
        }

        this.ownerSimilarAssets = this.ownerSimilarAssets.map(asset => {
          return populateAsset({
            asset,
            usersById: {},
            categoriesById: this.common.categoriesById,
            assetTypesById: this.common.assetTypesById,
            ratingsStatsByAssetId: this.rating.ratingsStatsByAssetId,
            ratingsOptions: this.ratingsOptions,
          })
        })
      }

      this.similarAssets = await this.$store.dispatch('fetchAssets', {
        // Restricting to same category for now
        filters: {
          quantity: 1,
          assetTypeId,
          similarTo: this.activeAsset.id,
          filter: ` _ownerId != ${ownerId}${
            this.activeAsset.categoryId ? ` && _categoryId[${this.activeAsset.categoryId}]` : ''
          }`
        },
        nbResults: 4
      })

      if (this.ratingActive) {
        const similarAssetIds = this.similarAssets.map(asset => asset.id)
        await this.$dispatch('fetchRatingsStats', { assetId: similarAssetIds, groupBy: 'assetId' })
      }

      this.similarAssets = this.similarAssets.map(asset => {
        return populateAsset({
          asset,
          usersById: {},
          categoriesById: this.common.categoriesById,
          assetTypesById: this.common.assetTypesById,
          ratingsStatsByAssetId: this.rating.ratingsStatsByAssetId,
          ratingsOptions: this.ratingsOptions,
        })
      })
    },
    resetTransactionParameters () {
      this.$store.commit(mutationTypes.SET_TRANSACTION_OPTIONS, {
        startDate: null,
        endDate: null,
        quantity: 1
      })
    },
    removeAsset (assetId) {
      const { id } = this.$route.params

      // if the asset removal concerns the current page, redirect to new asset
      if (assetId === id) {
        this.$router.push({ name: 'newAsset' })
      }
    }
  },
}
</script>

<style lang="stylus" scoped>
.country {
    text-align: left;
}
.country label {
    display: block;
    font-size: 16px;
}
.country select {
    font-size: 12px;
    min-height: 20px;
    line-height: 1;
    color: rgba(0,0,0,0.54);
    padding: 8px 12px 8px 0;
    width: 100%;
    border-radius: 0;
    border-width: 0 0 1px 0;
    border-color: #c2c2c2;
}
label.customck {
display: block;
    position: relative;
    padding-left: 75px;
    margin-bottom: 10px;
    cursor: pointer;
    font-size: 16px;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    line-height: 20px;
    min-height: 60px;
    padding-top: 20px;
}
.customck .checkmark:after {
        content: "";
        position: absolute;
        display: none;
      }
      .customck input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
      }
      .customck .checkmark {
        position: absolute;
    top: 20px;
    left: 20px;
    height: 20px;
    width: 20px;
    background-color: transparent;
    border-radius: 2px;
    border: 2px solid #484848;
      }
      label.customck:hover {
    background-color: #ededed;
}
      .customck input:checked ~ .checkmark:after {
        display: block;
      }
      .customck .checkmark:after {
  left: 8px;
    top: 2px;
    width: 7px;
    height: 15px;
    border: solid #fff;
    border-width: 0 3px 3px 0;
    -webkit-transform: rotate(
45deg
);
    transform: rotate(
45deg
);
      }
    .customck input:checked ~ .checkmark {
  background-color: #f00056;
    border: 2px transparent;
    width: 22px;
    height: 22px;
}
.justify-assets
  justify-content: center
  @media (min-width: $breakpoint-sm-min)
    justify-content: start

.transaction-card
  width: 300px
  border: 1px solid $grey-3
// .transaction-card__content
</style>
